import numpy as np
np.set_printoptions(precision=2, suppress=True)

A = np.array([[1, 2, 0],
              [0, 0, 5],
              [3, -4, 2],
              [1, 6, 5],
              [0, 1, 0]
             ])
print(f'Матрица A:\n{A}')

U, s, W = np.linalg.svd(A)

# Транспонируем матрицу W
V = W.T
# s - список диагональных элементов, его нужно привести к виду диагональной матрицы для наглядности
D = np.zeros_like(A, dtype=float)
D[np.diag_indices(min(A.shape))] = s

print(f'Матрица D:\n{D}')

print(f'Матрица U:\n{U}')

# Убедимся, что она действительно ортогональна
print(f'Проверка ортогональности U:\n{np.dot(U.T, U)}')

print(f'Матрица V:\n{V}')

# Убедимся, что она действительно ортогональна
print(f'Проверка ортогональности V:\n{np.dot(V.T, V)}')

# Проведем проверку
print(f'Итоговая проверка:\n{np.dot(np.dot(U, D), V.T)}')


evklid = np.linalg.norm(A, ord=2)
print(f'Евклидова норма вектора A:\n{evklid}')


frobenius = np.linalg.norm(A,'fro')
print(f'Норма Фробениуса для A:\n{frobenius}')








Матрица A:
[[ 1  2  0]
 [ 0  0  5]
 [ 3 -4  2]
 [ 1  6  5]
 [ 0  1  0]]
Матрица D:
[[8.82 0.   0.  ]
 [0.   6.14 0.  ]
 [0.   0.   2.53]
 [0.   0.   0.  ]
 [0.   0.   0.  ]]
Матрица U:
[[ 0.17  0.16 -0.53 -0.8  -0.16]
 [ 0.39 -0.53  0.61 -0.43  0.03]
 [-0.14 -0.82 -0.52  0.14  0.07]
 [ 0.89  0.06 -0.25  0.38 -0.06]
 [ 0.08  0.11 -0.08 -0.11  0.98]]
Проверка ортогональности U:
[[ 1.  0. -0.  0. -0.]
 [ 0.  1.  0.  0.  0.]
 [-0.  0.  1. -0. -0.]
 [ 0.  0. -0.  1. -0.]
 [-0.  0. -0. -0.  1.]]
Матрица V:
[[ 0.07 -0.37 -0.93]
 [ 0.72  0.67 -0.21]
 [ 0.69 -0.65  0.31]]
Проверка ортогональности V:
[[ 1.  0. -0.]
 [ 0.  1. -0.]
 [-0. -0.  1.]]
Итоговая проверка:
[[ 1.  2.  0.]
 [ 0. -0.  5.]
 [ 3. -4.  2.]
 [ 1.  6.  5.]
 [-0.  1. -0.]]
Евклидова норма вектора а:
8.824868854820444
Норма Фробениуса для A:
11.045361017187261
